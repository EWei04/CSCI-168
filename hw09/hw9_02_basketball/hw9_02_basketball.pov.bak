#version 3.7;

global_settings {
    ambient_light rgb <1, 1, 1>
}

// Camera setup
camera {
    location <0, 3.5, -6>
    look_at <0, 0, 0>
}

// Light sources
light_source {
    <1, 1, -1>
    rgb <1, 1, 1>
}

light_source {
    <0, 10, -10>
    rgb <1, 1, 1>
}

// Floor
plane {
    y, 0
    texture {
        pigment { image_map { png "https://media.istockphoto.com/id/1215073203/vector/watercolor-seamless-background-with-green-square-tile.jpg?s=612x612&w=0&k=20&c=b9OaODKEURg2t9hh7CAY9AkKqeDRg3gakCAG6ozBCI4=" } }
        finish {
            ambient 0.2
            diffuse 0.8
            reflection 0.2
        }
    }
}

// Wall
plane {
    y, 5
    texture {
        pigment { image_map { png "https://media.istockphoto.com/id/173585101/photo/faux-stone-warm-leather-001-xxl.jpg?s=612x612&w=0&k=20&c=5TPbXOoIJ84sBQ-k-SM0tFYEQkLMs1ULJC1MD23VSdU=" } }
        finish {
            ambient 0.2
            diffuse 0.8
            reflection 0.2
        }
    }
    translate <0, 0, -2>
}

// Basketball
sphere {
    <0, 0.8, 0>, 0.8
    texture {
        pigment { image_map { png "https://static.turbosquid.com/Preview/Content_2010_02_27__23_25_12/Basketball+texture.jpg449ad06d-12b1-4d99-b7d8-e11229001e82Zoom.jpg" } }
        finish {
            ambient 0.2
            diffuse 0.7
            reflection 0.1
        }
    }
}

// Background color
background { rgb <1, 1, 1> }

// Render settings
#declare FrameCount = 60; // Set the number of frames for animation
#declare FrameRate = 30; // Set the frame rate

// Animation
#declare time = 0;
#declare now = 0;
#declare by = 5; // Initial height
#declare bx = -5; // Initial x position
#declare dx = 3; // X velocity
#declare dy = 0; // Initial Y velocity
#declare g = -9.8; // Gravity
#declare damp = 0.5; // Damping factor for bounce

#declare rotationSpeed = 0;
#declare baseRotationSpeed = 5;
#declare lastBounce = false; // Track if the ball bounced in the previous frame

#while (bx < 10)
    // Update position based on velocity
    #declare bx = bx + dx * (now - time);
    #declare by = by + dy * (now - time);
    
    // Gravity
    #declare dy = dy + g * (now - time);
    
    #if (by < 0.8)
        #declare by = 0.8;
        #declare bounced = true;
        
        #if (abs(dy) < -g/6)
            // Very small bounce - stop the ball
            #declare dy = 0;
            #declare g = 0;
            #declare rotationSpeed = 1.4;
        #else
            // Bounce with damping
            #declare impactForce = abs(dy); // Store impact force before damping
            #declare dy = -dy * damp;
            
            // Set rotation speed based on horizontal velocity
            #declare rotationSpeed = baseRotationSpeed * sign(dx) * min(1, abs(dy) / 10);
        #end
    #else
        #declare bounced = false;
    #end
    
    // If the ball just bounced (and wasn't bouncing before), adjust rotation
    #if (bounced && !lastBounce && abs(dy) > 0.1)
        // Increase rotation on bounce
        #declare rotationSpeed = baseRotationSpeed * sign(dx) * min(1.5, abs(dy) / 8);
    #end
    
    // Update bounce state for next frame
    #declare lastBounce = bounced;
    
    // Update ball position
    object {
        sphere
        translate <bx, by, 0>
        rotate <0, 0, -rotationSpeed * (now - time)>
    }
    
